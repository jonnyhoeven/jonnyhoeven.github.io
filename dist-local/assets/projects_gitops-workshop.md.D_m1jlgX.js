import{_ as i,c as t,m as e,a as s,t as n,a5 as l,o}from"./chunks/framework.efMJGC9V.js";const f=JSON.parse('{"title":"Git Ops Workshop","description":"","frontmatter":{"title":"Git Ops Workshop","image":"/images/gitops-workshop.png","githost":"https://github.com","user":"jonnyhoeven","project":"workshop","languages":"Kubernetes","prev":{"text":"Projects","link":"/projects"},"outline":"deep"},"headers":[],"relativePath":"projects/gitops-workshop.md","filePath":"projects/gitops-workshop.md","lastUpdated":1710662172000}'),p={name:"projects/gitops-workshop.md"},h=e("h2",{id:"this-workshop-is-designed-to-provide-a-basic-understanding-of-kubernetes-and-argocd-this-workshop-will-teach-you-how-to-create-your-own-kubernetes-cluster-using-k3s-and-argocd-to-deploy-your-firstapplication-from-a-git-ops-perspective-this-is-the-git-ops-way",tabindex:"-1"},[s("This workshop is designed to provide a basic understanding of Kubernetes and ArgoCD. This Workshop will teach you how to create your own Kubernetes cluster using K3S and ArgoCD to deploy your first application from a Git-Ops perspective. This is the "),e("code",null,"Git-Ops"),s(" way. "),e("a",{class:"header-anchor",href:"#this-workshop-is-designed-to-provide-a-basic-understanding-of-kubernetes-and-argocd-this-workshop-will-teach-you-how-to-create-your-own-kubernetes-cluster-using-k3s-and-argocd-to-deploy-your-firstapplication-from-a-git-ops-perspective-this-is-the-git-ops-way","aria-label":'Permalink to "This workshop is designed to provide a basic understanding of Kubernetes and ArgoCD.\nThis Workshop will teach you how to create your own Kubernetes cluster using K3S and ArgoCD to deploy your first \napplication from a Git-Ops perspective. This is the `Git-Ops` way."'},"​")],-1),r={id:"frontmatter-title",tabindex:"-1"},d=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),c=e("iframe",{src:"https://docs.google.com/presentation/d/e/2PACX-1vTwUNGkjI-YYRBIXGol9IpAwuzhIPCXTP01DUP8k-cV1_0Z8Kilxw6VyfaXS70pRMfuTJeTrYkpZS0C/embed?start=false&loop=false&delayms=15000",frameborder:"0",width:"100%",height:"414pt",allowfullscreen:"true",mozallowfullscreen:"true",webkitallowfullscreen:"true"},null,-1),k=l(`<h2 id="gitops-using-argocd" tabindex="-1">GitOps using ArgoCD <a class="header-anchor" href="#gitops-using-argocd" aria-label="Permalink to &quot;GitOps using ArgoCD&quot;">​</a></h2><h3 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h3><p>This workshop is designed to provide a basic understanding of Kubernetes and ArgoCD.</p><p>During the workshop, we&#39;ll be deploying a simple application to a Kubernetes cluster using Kubectl and then we&#39;ll deploy the same application using ArgoCD.</p><h3 id="kubernetes-concepts" tabindex="-1">Kubernetes concepts <a class="header-anchor" href="#kubernetes-concepts" aria-label="Permalink to &quot;Kubernetes concepts&quot;">​</a></h3><p>Kubernetes is a container orchestration platform that automates deployment, scaling and management of containerized applications.</p><p>It&#39;s declarative, meaning you define the desired state of the system and Kubernetes automatically changes the current state to the desired state the best way it can.</p><p>It&#39;s designed to be extensible and scalable and it&#39;s built to handle a wide range of workloads, from stateless to stateful applications.</p><h3 id="extendable-custom-resource-definitions-crd-s" tabindex="-1">Extendable - Custom Resource Definitions (CRD&#39;s) <a class="header-anchor" href="#extendable-custom-resource-definitions-crd-s" aria-label="Permalink to &quot;Extendable - Custom Resource Definitions (CRD&#39;s)&quot;">​</a></h3><p>Kubernetes utilizes Custom Resource Definitions (CRDs) for extendability.</p><p>CRDs allow extendability for the Kubernetes API by creating new resources classes.</p><p>This allows developers to create their own resources or controllers to manage these resources.</p><p>For example, the ArgoCD operator creates a new resource called an Application. This resource can be used to define applications and their configuration in a declarative way. It&#39;s then up to the ArgoCD operator to manage these applications and ensure they&#39;re in the desired state.</p><p>It&#39;s important to understand that CRD&#39;s are methods to extend the Kubernetes API and create new resources. This concept is used in many operators, controllers, helm charts, ingress classes, storage classes to create new resources and manage them individually.</p><h3 id="declarative-vs-imperative" tabindex="-1">Declarative vs Imperative <a class="header-anchor" href="#declarative-vs-imperative" aria-label="Permalink to &quot;Declarative vs Imperative&quot;">​</a></h3><p>Declarative means you define the desired state of the system and Kubernetes automatically changes the current state to the desired state the best way it can.</p><p>This has a mayor impact, small changes in the desired state can have a big impact on the current state. It&#39;s important to understand the difference between the desired states of the system to prevent unwanted changes.</p><p>However, it&#39;s also a powerful tool to manage the system. Instead of writing a series of commands to put the system in a certain state, you declare the desired state and Kubernetes will do the rest.</p><h3 id="health-checks" tabindex="-1">Health Checks <a class="header-anchor" href="#health-checks" aria-label="Permalink to &quot;Health Checks&quot;">​</a></h3><p>Health checks are integral to determine if a container is healthy or not. Kubernetes supports three types of health checks: livenessProbe, readinessProbe and startupProbe.</p><p>Kubernetes utilizes Health Probes to determine if a container is healthy or not. If a container isn&#39;t healthy, Kubernetes will restart the container. Afterwards Kubernetes will not send traffic to that container.</p><p>Developers can define the health-result of their application and Kubernetes will take care of the rest.</p><p>If you want to update a container image to a new version you can do this by updating the deployment manifest. Kubernetes sees the change in the desired state and will automatically update the running containers to the new version.</p><p>However, Kubernetes won&#39;t just kill the old containers and start new ones. It will do this in a controlled manner. It first starts up the new container and waits for it to be healthy. Then it will stop the old container to prevent downtime. It&#39;s therefore important to have concise health checks in place, developers should be encouraged to manipulate health checks if they deem a service misbehaving or unavailable.</p><h3 id="containers-reside-in-pods" tabindex="-1">Containers reside in Pods <a class="header-anchor" href="#containers-reside-in-pods" aria-label="Permalink to &quot;Containers reside in Pods&quot;">​</a></h3><p>A Pod is the smallest deployable unit in Kubernetes. A Pod represents a single instance of a running process in your cluster. Pods contain one or more containers. When a Pod runs multiple containers, the containers are managed as a single entity and share the same resources.</p><p>More importantly, containers in a pod share the same lifecycle, they&#39;re started together, stopped together and are considered atomic.</p><p>A Pod can be considered a separate subnetwork, containers within a pod are effectively behind NAT (Network Address Translation). Inside this Pod containers can rely on a local DNS service to resolve hostnames to each internally.</p><p>Since networking and state is separate and also atomic this means you can run multiple replica&#39;s of the same Pod and increase availability. Without the need to worry about state or networking from a container perspective.</p><h3 id="pods-expose-their-ports-to-services" tabindex="-1">Pods expose their ports to Services <a class="header-anchor" href="#pods-expose-their-ports-to-services" aria-label="Permalink to &quot;Pods expose their ports to Services&quot;">​</a></h3><p>Services provide a method to expose an application running on a set of Pod replica&#39;s as a network service. Services are mostly abstraction/glue for Pods and Ingress. They provide a stable endpoint for Pods and Ingress to connect.</p><h3 id="ingress-connects-services-to-the-outside-world" tabindex="-1">Ingress connects Services to the outside world <a class="header-anchor" href="#ingress-connects-services-to-the-outside-world" aria-label="Permalink to &quot;Ingress connects Services to the outside world&quot;">​</a></h3><p>Ingress is a collection of rules that allows inbound connections to reach the cluster Services. It&#39;s used to allow external ingress to different services via ports, load balancers, URL hostname. Plugins for Common Authority Certificates en Cert Manager using Let&#39;s Encrypt are easily installed.</p><h3 id="namespaces" tabindex="-1">Namespaces <a class="header-anchor" href="#namespaces" aria-label="Permalink to &quot;Namespaces&quot;">​</a></h3><p>Another important concept in Kubernetes is Namespaces. Namespaces are used to divide cluster resources between different tenants, teams or applications.</p><p>It&#39;s a powerful tool to divide resources and provides isolation between different applications. Commonly used to divide resources between different environments like development, staging and production. Ideally the only difference between staging and production should be a namespace Configmap and Secrets.</p><p>The <code>default</code> namespace is the default namespace for objects with no other namespace. It&#39;s important to note that namespaces are not a security boundary, just methods to divide resources and provide isolation between different applications. It&#39;s important to note that resources in different namespaces can communicate with each other.</p><h3 id="configmaps-and-secrets" tabindex="-1">ConfigMaps and Secrets <a class="header-anchor" href="#configmaps-and-secrets" aria-label="Permalink to &quot;ConfigMaps and Secrets&quot;">​</a></h3><p>ConfigMaps are a Kubernetes resources that allows decoupled configuration artifacts from image content in an effort to keep containerized applications portable.</p><p>When you need to store sensitive information, such as passwords, OAuth tokens and SSH keys, you can use Secrets. If you need to store non-sensitive configuration data, you can use ConfigMaps.</p><p>ConfigMaps and Secrets can be mounted as files or environment variables in a Pod. Containers in a pod might need to be drained to apply the latest configuration changes.</p><h3 id="pod-reload" tabindex="-1">Pod Reload <a class="header-anchor" href="#pod-reload" aria-label="Permalink to &quot;Pod Reload&quot;">​</a></h3><p>In most cases (when no active &quot;operator&quot; is present) a pod will not reload when a configmap or secret is updated. This is because the pod is not aware of the change and won&#39;t get drained.</p><h3 id="draining" tabindex="-1">Draining <a class="header-anchor" href="#draining" aria-label="Permalink to &quot;Draining&quot;">​</a></h3><p>Draining is the process of gracefully terminating a node and moving its workloads to other nodes in the cluster. This is useful when you need to perform maintenance on a node or when you want to remove the workload while maintaining availability using the other nodes.</p><p>This also applies to pods, when a pod is draining it will not accept new connections and will gracefully terminate. <strong>Don&#39;t delete pods when there is no other replica, use the drain command.</strong></p><h3 id="persistent-volumes-claims-and-storage-classes" tabindex="-1">Persistent Volumes Claims and Storage Classes <a class="header-anchor" href="#persistent-volumes-claims-and-storage-classes" aria-label="Permalink to &quot;Persistent Volumes Claims and Storage Classes&quot;">​</a></h3><p>It&#39;s important to note that k3s is a lightweight Kubernetes distribution and does not come with most storage classes. Most of these classes are provided by the cloud provider or need to be installed manually when on bare metal.</p><h3 id="difference-between-k3s-and-k8s" tabindex="-1">Difference between k3s and k8s <a class="header-anchor" href="#difference-between-k3s-and-k8s" aria-label="Permalink to &quot;Difference between k3s and k8s&quot;">​</a></h3><p>K3s is a lightweight Kubernetes distribution. It is a fully compliant Kubernetes distribution some differences.</p><p>K3S is a lightweight Kubernetes distribution. It is a fully compliant Kubernetes distribution with some differences. It&#39;s a perfect candidate for edge computing, IoT and CI/CD. It&#39;s lightweight, easy to install and has a small footprint.</p><p>K8S contains a lot of features in the default build that are not always needed, helm charts for most missing k3s features can also be installed via helm charts.</p><p>Some feature differences:</p><ul><li>Included Storage classes</li><li>Traefik ingress controller</li><li>Arm64 support</li><li>Memory footprint</li></ul><h3 id="helm" tabindex="-1">Helm <a class="header-anchor" href="#helm" aria-label="Permalink to &quot;Helm&quot;">​</a></h3><p>Helm is a package manager for Kubernetes. It allows you to define, install and upgrade complex Kubernetes applications. Helm is a tool that streamlines installing and managing Kubernetes applications.</p><p>Think of it like apt/yum/homebrew for Kubernetes. Helm charts allow you to define values that control the applied Kubernetes manifests.</p><p>Helm charts are available for most applications and services.</p><p>When ArgoCD is available on a cluster it&#39;s important to note that helm can be handled differently in ArgoCD. Helm charts can be installed as a regular application in ArgoCD.</p><p>Helm charts are handled differently with ArgoCD to provide rollbacks and prevent influence from volatile external sources.</p><h2 id="the-workshop" tabindex="-1">The Workshop <a class="header-anchor" href="#the-workshop" aria-label="Permalink to &quot;The Workshop&quot;">​</a></h2><p>We&#39;re going to deploy a simple application to a Kubernetes cluster using Kubectl, then we&#39;ll deploy the same application using ArgoCD, along the way we&#39;ll be checking out multiple tools to configure a kubernetes cluster.</p><p>We&#39;ll end up with a cluster you can tinker with from your own git repository.</p><p>Let&#39;s get started, first open up a terminal to run linux/bash commands.</p><p>ArgoCD can be installed as highly available (all nodes have replicated state) or on one node. It&#39;s a continuous delivery tool for Kubernetes based on external sources, most commonly git repositories.</p><p>It follows the GitOps pattern of using Git repositories as the source of <em>truth</em> for defining the desired application state. ArgoCD is very declarative and all it&#39;s configuration is stored in a Git repositories.</p><h3 id="requirements" tabindex="-1">Requirements <a class="header-anchor" href="#requirements" aria-label="Permalink to &quot;Requirements&quot;">​</a></h3><p>We&#39;ll need some tools to get our cluster running.</p><h3 id="kubectl-kube-cuttle-or-kube-control" tabindex="-1">Kubectl (Kube-Cuttle or Kube-Control) <a class="header-anchor" href="#kubectl-kube-cuttle-or-kube-control" aria-label="Permalink to &quot;Kubectl (Kube-Cuttle or Kube-Control)&quot;">​</a></h3><p>Kubectl is a command line tool for controlling Kubernetes clusters. It&#39;s used to deploy, inspect and manage cluster.</p><p><a href="https://kubernetes.io/docs/tasks/tools/install-Kubectl-linux/" target="_blank" rel="noreferrer">Reference</a></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># apt-transport-https may be a dummy package; if so, you can skip that package</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt-get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -y</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt-transport-https</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ca-certificates</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> curl</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># If the folder \`/etc/apt/keyrings\` does not exist, it should be created before the curl command.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mkdir</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 755</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/apt/keyrings</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -fsSL</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gpg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --dearmor</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/apt/keyrings/kubernetes-apt-keyring.gpg</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># This overwrites any existing configuration in /etc/apt/sources.list.d/kubernetes.list</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tee</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/apt/sources.list.d/kubernetes.list</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt-get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> update</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt-get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -y</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> kubectl</span></span></code></pre></div><h3 id="k3d-k3s-in-docker-cluster-setup" tabindex="-1">K3D (K3S in Docker) cluster setup <a class="header-anchor" href="#k3d-k3s-in-docker-cluster-setup" aria-label="Permalink to &quot;K3D (K3S in Docker) cluster setup&quot;">​</a></h3><p>K3D is a lightweight wrapper to run K3S (Rancher Lab&#39;s minimal Kubernetes distribution) in docker. It&#39;s a single binary that deploys a K3S server in a docker container. K3D makes it very easy to create single and multi-node K3S clusters in docker, it&#39;s possible to run multiple clusters at the same time on your development machine.</p><p><a href="https://k3d.io/v5.6.0/#quick-start" target="_blank" rel="noreferrer">Reference</a></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wget</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -q</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -O</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> -</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bash</span></span></code></pre></div><h3 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;Docker&quot;">​</a></h3><ul><li><p><strong>Windows</strong> you&#39;ll need <a href="https://www.docker.com/products/docker-desktop/" target="_blank" rel="noreferrer">Docker Desktop</a>.</p></li><li><p><strong>Linux</strong> Install Docker.io:</p></li></ul><p><a href="https://packages.debian.org/sid/docker.io" target="_blank" rel="noreferrer">Reference</a></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker.io</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> groupadd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> usermod</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -aG</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $USER</span></span></code></pre></div><h3 id="lens" tabindex="-1">Lens <a class="header-anchor" href="#lens" aria-label="Permalink to &quot;Lens&quot;">​</a></h3><p>Lens is a Kubernetes IDE that allows you to manage, monitor and manipulate your clusters.</p><p>Recently some features were removed from Open Lens. Plugins replacing this functionality aren&#39;t yet working properly. So for now, it&#39;s recommended to use the Mirantis Free version of Lens.</p><ul><li><a href="https://k8slens.dev/desktop.html" target="_blank" rel="noreferrer">Lens</a> (Mirantis)</li><li><a href="https://flathub.org/apps/dev.k8slens.OpenLens" target="_blank" rel="noreferrer">Open Lens</a> (Open Source version)</li></ul><h3 id="starting-your-kubernetes-cluster" tabindex="-1">Starting your Kubernetes cluster <a class="header-anchor" href="#starting-your-kubernetes-cluster" aria-label="Permalink to &quot;Starting your Kubernetes cluster&quot;">​</a></h3><p><a href="https://k3d.io/v5.3.0/usage/commands/k3d_cluster_create/" target="_blank" rel="noreferrer">Reference</a></p><p>We&#39;ll be creating 1 server and 2 agents for our cluster. Normally for high availability you&#39;ll want to have at least 2 control planes, with 2 agents/workers <em>each</em>. For this example we&#39;ll keep it simple.</p><p>We&#39;ll name this cluster <code>workshop</code>.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> k3d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cluster</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --agents</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --servers</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div><p>Once completed, you can check the status of your cluster by running:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> k3d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cluster</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> list</span></span></code></pre></div><h3 id="access-the-cluster-using-kubectl" tabindex="-1">Access the cluster using Kubectl <a class="header-anchor" href="#access-the-cluster-using-kubectl" aria-label="Permalink to &quot;Access the cluster using Kubectl&quot;">​</a></h3><p>Kubeconfig is a file that holds information about clusters, including the hostname, certificate authority and authentication information. It&#39;s located at <code>~/.kube/config</code> by default and can be used by other applications to connect to the cluster. Keep this file secure, it&#39;s the <strong>key</strong> to your cluster.</p><p>You can get the kubeconfig file from K3D by running:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> k3d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> kubeconfig</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> kubeconfig.yaml</span></span></code></pre></div><ul><li>Update your user <code>~/.kube/config</code> file with the newly generated <a href="kubeconfig.yaml">kubeconfig.yaml</a> file.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mv</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~/.kube/config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~/.kube/config-$(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uuidgen</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #Backup any existing kubeconfig</span></span></code></pre></div><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mv</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./kubeconfig.yaml</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~/.kube/config</span></span></code></pre></div><ul><li>Check cluster info</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cluster-info</span></span></code></pre></div><ul><li>Check the cluster Nodes</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nodes</span></span></code></pre></div><h3 id="access-the-cluster-using-lens" tabindex="-1">Access the cluster using Lens <a class="header-anchor" href="#access-the-cluster-using-lens" aria-label="Permalink to &quot;Access the cluster using Lens&quot;">​</a></h3><p>Setup Lens to use the new cluster by adding a new cluster from the <a href="kubeconfig.yaml">kubeconfig.yaml</a> file.</p><ul><li><p>Click on <code>Catalog</code> (Top left, second from top) → <code>Clusters</code> → <code>Add Cluster (+) icon</code> → <code>Add Cluster from Kubeconfig</code> → Paste the contents of your kubeconfig file → <code>Add Clusters</code></p></li><li><p>Or import the kubeconfig file using the <code>Add Cluster from Kubeconfig</code> option.</p></li></ul><p>Now you can access the <code>k3d-workshop</code> cluster using Lens.</p><p>Browse around, check the <code>Nodes</code>, <code>Namespaces</code>, <code>Custom Resource Definitions</code> and <code>Pods</code>.</p><h3 id="some-notes-about-namespaces" tabindex="-1">Some notes about Namespaces <a class="header-anchor" href="#some-notes-about-namespaces" aria-label="Permalink to &quot;Some notes about Namespaces&quot;">​</a></h3><p>Namespaces divide cluster resources and quota&#39;s. They&#39;re intended for use in environments with many users spread across multiple teams or projects. Namespaces are not a security feature, to isolate different users or namespaces from each other we need tools like <a href="https://loft.sh/" target="_blank" rel="noreferrer">Loft</a> that leverage RBAC (Role based account control) to securely isolate namespaces across teams.</p><p>By default, Kubernetes starts with four initial namespaces:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> namespaces</span></span></code></pre></div><ul><li><code>default</code>, The default namespace for objects with no other namespace. Try not to use this namespace for your own objects.</li><li><code>kube-system</code>, The namespace for objects created by the Kubernetes system.</li><li><code>kube-public</code>, This namespace is created automatically and is readable by all users (including those not authenticated).</li><li><code>kube-node-lease</code>, This namespace is used for the lease objects associated with each <code>node</code> which improves the performance of the <code>node</code> heartbeats as the cluster scales.</li></ul><h3 id="create-your-own-namespace" tabindex="-1">Create your own namespace <a class="header-anchor" href="#create-your-own-namespace" aria-label="Permalink to &quot;Create your own namespace&quot;">​</a></h3><p>Let&#39;s create a new namespace and deploy an application in the <code>workshop</code> namespace.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> namespace</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span></span></code></pre></div><h3 id="deploy-an-application-manually" tabindex="-1">Deploy an application manually <a class="header-anchor" href="#deploy-an-application-manually" aria-label="Permalink to &quot;Deploy an application manually&quot;">​</a></h3><p>We&#39;ll deploy nginx web server to our cluster.</p><p>The <code>-n</code> or <code>--namespace</code> parameter is used to specify the namespace to deploy the application to. If you don&#39;t provide a namespace, the application will deploy to the <code>default</code> namespace. Resulting in naming conflicts and hard to find, hard to manage resources.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --image=nginx</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span></span></code></pre></div><ul><li>Check the <code>deployment</code> and <code>pod</code> status with Kubectl</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span></span></code></pre></div><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span></span>
<span class="line"><span>nginx   1/1     1            1           2m3s</span></span></code></pre></div><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pod</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span></span></code></pre></div><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># NAME                     READY   STATUS    RESTARTS   AGE</span></span>
<span class="line"><span># nginx-7854ff8877-z9j2t   1/1     Running   0          49s</span></span></code></pre></div><ul><li><p>Find the <code>deployment</code> in lens and check the <code>pod</code> status. As you can see, the <code>deployment</code> and <code>pod</code> replica is up and running.</p></li><li><p>Try deleting the <code>pod</code> and see what happens.</p></li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> delete</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pod</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> $(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get pods </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> jsonpath=&quot;{.items[*].metadata.name}&quot;)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span></span></code></pre></div><p>The <code>pod</code> gets deleted and a new one is created to replace it. This is because the <code>deployment</code> is set to have 1 replica, so if the <code>pod</code> is deleted, a new one is created to replace it.</p><ul><li>List the <code>pods</code> again</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pod</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span></span></code></pre></div><p>The <code>pod</code> is running again, but now it&#39;s got a <em>different</em> name.</p><p>It&#39;s important to note that the <code>deployment</code> manifest manages the <code>pod</code> and a <code>pod</code> can be replicated.</p><p>To avoid downtime it&#39;s recommended to use <code>Evict</code> or <code>Taint</code> instead of deleting definitions. This will result in kubernetes creating a new <code>pod</code> and wait for it to be ready before deleting the old <code>evicted pod</code>.</p><ul><li>Delete the <code>deployment</code> and check the <code>pod</code> status again.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> delete</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span></span></code></pre></div><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pod</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span></span></code></pre></div><p>Without the <code>deployment</code> manifest with a minimal <code>pod</code> replica count, the <code>pod</code> is removed.</p><ul><li>Clean up the namespace.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> delete</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> namespace</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span></span></code></pre></div><h3 id="deploy-using-manifest-files-from-code" tabindex="-1">Deploy using manifest files from code <a class="header-anchor" href="#deploy-using-manifest-files-from-code" aria-label="Permalink to &quot;Deploy using manifest files from code&quot;">​</a></h3><p>Normally you&#39;ll want to deploy using a manifest file, so you can keep track of your <code>deployments</code> and easily replicate them across different clusters or namespaces.</p><p><strong>Before starting make sure you&#39;re in the correct working directory.</strong></p><ul><li>Create the <code>cat-app</code> namespace using Kubectl:</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> namespace</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat-app</span></span></code></pre></div><ul><li>Deploy the cat-app <code>deployment</code> to the <code>cat-app</code> namespace using the manifest files.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./namespace/cat-app/cat-app.Deployment.yaml</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat-app</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./namespace/cat-app/cat-app.Service.yaml</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat-app</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./namespace/cat-app/cat-app.Ingress.yaml</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat-app</span></span></code></pre></div><ul><li>You can deploy a complete folder using Kubectl, this will deploy all the files in one folder, try it.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./namespace/cat-app/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat-app</span></span></code></pre></div><ul><li>Get familiar with the files in the <code>cat-app</code> folder and try to understand what each file does.</li><li>Notice the URL in the cat-app.Ingress.yaml file, this is the <code>URL</code>, <code>Virtual Host</code> you&#39;ll use to access the cat-app.</li><li>Notice the <code>Service</code> file, this is the service that will be used to expose the cat-app to the internet. it uses the type <code>ClusterIP</code>.</li><li>For now check the <code>deployment</code> and <code>pod</code> status with Kubectl or lens.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat-app</span></span></code></pre></div><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pod</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat-app</span></span></code></pre></div><ul><li>Check the service and ingress status with Kubectl or lens.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> service</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat-app</span></span></code></pre></div><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ingress</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat-app</span></span></code></pre></div><p>Ingress is a collection of classes that allow inbound connections to reach the cluster services. It can be configured to give services externally-reachable URLs, load balance traffic, terminate SSL, offer name-based virtual hosting and more.</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>NAME      CLASS    HOSTS               ADDRESS                            PORTS   AGE</span></span>
<span class="line"><span>cat-app   &lt;none&gt;   cat-app.k3d.local   172.20.0.2,172.20.0.3,172.20.0.4   80      2m1s</span></span></code></pre></div><ul><li>Notice the <code>cat-app.k3d.local</code> URL, this is the URL you&#39;ll use to access the cat-app.</li><li>Notice the <code>ADDRESS</code> field, this is the IP address of the service, it&#39;s a <code>ClusterIP</code> type service and is available on all kubernetes Nodes in the cluster. If a node does not have the cat-app <code>pod</code>, it will forward the request to other nodes that host the cat-app <code>pod</code> selector.</li><li>More commonly you&#39;ll see <code>LoadBalancer</code> type services, which use cloud provider&#39;s or on premises load balancers to expose the services to other networks/internet.</li></ul><h3 id="accessing-the-cat-app" tabindex="-1">Accessing the cat-app <a class="header-anchor" href="#accessing-the-cat-app" aria-label="Permalink to &quot;Accessing the cat-app&quot;">​</a></h3><p>First we need to update our hosts file, normally you&#39;ll use a DNS server to resolve the URL to the IP address and sign TLS certificates automatically with <code>let&#39;s encrypt</code> or a <code>Common Authority</code> certificate.</p><ul><li>Use the output above to update your hosts file:</li></ul><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># Workshop K3D cluster</span></span>
<span class="line"><span>172.xx.0.2 cat-app.k3d.local</span></span>
<span class="line"><span>172.xx.0.3 cat-app.k3d.local</span></span>
<span class="line"><span>172.xx.0.4 cat-app.k3d.local</span></span>
<span class="line"><span>172.xx.0.2 argocd.k3d.local</span></span>
<span class="line"><span>172.xx.0.3 argocd.k3d.local</span></span>
<span class="line"><span>172.xx.0.4 argocd.k3d.local</span></span></code></pre></div><ul><li>Add the correct IP addresses to your hosts file:</li></ul><p>Windows:</p><ul><li>Open notepad as administrator, open the file <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></li></ul><p>Linux:</p><ul><li>Edit your hosts file.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nano</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/hosts</span></span></code></pre></div><p>Now browse to <a href="https://cat-app.k3d.local/" target="_blank" rel="noreferrer">http://cat-app.k3d.local/</a>, you should see the nginx welcome page.</p><h3 id="start-deploying-using-argocd" tabindex="-1">Start deploying using ArgoCD <a class="header-anchor" href="#start-deploying-using-argocd" aria-label="Permalink to &quot;Start deploying using ArgoCD&quot;">​</a></h3><ul><li>Make sure you forked this repo and cloned your forked repo to your local machine before editing files. Later on we&#39;ll use your fork to steer your local cluster.</li><li>Push any changes to your fork: This is the <code>GitOps</code> way.</li><li>To use ArgoCD we need to create the <code>argocd</code> namespace and deploy the ArgoCD application with <code>configmap</code>, <code>ingress</code> and <code>service</code>. This is not recursive, only files in the <code>argocd</code> folder will be deployed, sub folders are ignored.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> namespace</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> argocd</span></span></code></pre></div><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./namespace/argocd</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> argocd</span></span></code></pre></div><ul><li>Extract the ArgoCD admin password, we first request the secret and then decode the password using base64 to plain text. The initial password is randomly generated and unique to each ArgoCD installation.</li><li>ArgoCD also provides a CLI tool to interact with the API, but for now we&#39;ll use kubectl.</li><li>We should delete this <code>ConfigMap</code> manifest and create a new password.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> secret</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> argocd-initial-admin-secret</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> argocd</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> jsonpath=&#39;{.data.password}&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> base64</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --decode</span></span></code></pre></div><p>*** Ignore the <code>%</code> when pasting the password. ***</p><ul><li>Browse to <a href="https://argocd.k3d.local" target="_blank" rel="noreferrer">argocd.k3d.local</a></li><li>username: <code>admin</code></li><li>password: <code>password from previous command</code></li></ul><p>Normally we would delete this initial secret after using it and set a new admin password, Ffr now we&#39;ll keep it as is.</p><ul><li>This repository includes an <a href="/namespace/argocd/repository/argocd.Repository.yaml">argocd.Repository</a> file.</li><li>Update the repo url in this file to your forked repository.</li><li>Apply the Repository using Kubectl.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./namespace/argocd/repository/argocd.Repository.yaml</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> argocd</span></span></code></pre></div><ul><li><p>Your forked <a href="https://argocd.k3d.local/settings/repos" target="_blank" rel="noreferrer">repository</a> is now visible in the ArgoCD UI.</p></li><li><p>Update the Repository URL in the <a href="namespace/argocd/application/cat-app.Application.yaml">cat-app.Application</a> file.</p></li><li><p>Push this change to your fork.</p></li><li><p>Now, Apply the application to the ArgoCD namespace.</p></li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./namespace/argocd/application/cat-app.application.yaml</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> argocd</span></span></code></pre></div><ul><li>Browse to <a href="https://argocd.k3d.local/applications/argocd/cat-app" target="_blank" rel="noreferrer">https://argocd.k3d.local/applications/argocd/cat-app</a></li><li>Press the <code>sync</code> button to sync the application with your forked repository.</li><li>Your cat app is now deployed using ArgoCD.</li></ul><h3 id="argocd-can-git-ops-itself" tabindex="-1">ArgoCD can Git Ops itself <a class="header-anchor" href="#argocd-can-git-ops-itself" aria-label="Permalink to &quot;ArgoCD can Git Ops itself&quot;">​</a></h3><p>We just deployed the cat app using ArgoCD, but we still needed Kubectl to apply the application. ArgoCD can also manage itself using GitOps, we can deploy the <code>cat-app</code> by adding a new file in the <code>namespace/argocd/application</code> folder.</p><ul><li><p>First edit <a href="/namespace/argocd/application/argocd.Application.yaml">argocd.application.yaml</a> and change <code>repoURL</code> to your fork.</p></li><li><p>Commit and push the changes to your fork</p></li><li><p>Apply the application to ArgoCD</p></li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./namespace/argocd/application/argocd.Application.yaml</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> argocd</span></span></code></pre></div><p>Since we added the application to the repository and sync is enabled in the ArgoCD Application manifest file, it will automatically maintain the ArgoCD namespace based on the repository state.</p><ul><li>Try deleting the cat-app in the ArgoCD gui and see what happens</li></ul><p>Argo cd notices that the cat-app is missing and will automatically recreate/heal.</p><ul><li><p>Edit <a href="namespace/cat-app/cat-app.Deployment.yaml">cat-app.Deployment.yaml</a> and change the <code>replicas</code> to 3</p></li><li><p>Commit and push the changes to your fork</p></li><li><p>Go to the <a href="https://argocd.k3d.local/applications/argocd/cat-app?view=network&amp;resource=" target="_blank" rel="noreferrer">cat-app network resources view</a></p></li><li><p>Press the refresh button to check for git updates</p></li><li><p>The cat-app <code>deployment</code> is now updating to 3 replicas</p></li></ul><h3 id="what-do-you-want-to-host" tabindex="-1">What do you want to host? <a class="header-anchor" href="#what-do-you-want-to-host" aria-label="Permalink to &quot;What do you want to host?&quot;">​</a></h3><ul><li><p>Try playing around with your cluster, break it, fix it, add new applications</p></li><li><p>Open a shell to a container</p></li><li><p>Create a volume claim for persistent storage</p></li><li><p>Check out cool helm charts you can install within minutes. <a href="https://github.com/cdwv/awesome-helm" target="_blank" rel="noreferrer">awesome-helm</a></p></li></ul><p>If you have any questions or suggestions please let me know.</p><h3 id="delete-the-cluster" tabindex="-1">Delete the cluster <a class="header-anchor" href="#delete-the-cluster" aria-label="Permalink to &quot;Delete the cluster&quot;">​</a></h3><ul><li>To keep your system clean, you can delete the cluster by running:</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> k3d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cluster</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> delete</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> workshop</span></span></code></pre></div><ul><li>You can also delete the kubeconfig file by running:</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~/.kube/config</span></span></code></pre></div><ul><li>Optionally restore the original kubeconfig file you had before by running:</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mv</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~/.kube/config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">UUI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~/.kube/config</span></span></code></pre></div><ul><li>Restore your <code>hosts</code> file to its original state.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nano</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/hosts</span></span></code></pre></div>`,201);function u(a,g,y,F,b,m){return o(),t("div",null,[h,e("h1",r,[s(n(a.$frontmatter.title)+" ",1),d]),c,k])}const v=i(p,[["render",u]]);export{f as __pageData,v as default};
